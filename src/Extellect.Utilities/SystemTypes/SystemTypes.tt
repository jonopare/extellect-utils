<#@ template hostspecific="true" language="C#" debug="true" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Extellect" #>
<#@ output extension=".cs" #>
#if NETFULL
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#
	var document = new XmlDocument();
	document.Load(Host.ResolvePath(@".\SystemTypes.xml"));
	foreach (XmlElement typeNode in document.SelectNodes(@"/types/type"))
	{
		var typeName = typeNode.Attributes["name"]?.Value;
		if (typeName == null)
		{
			continue;
		}
		var type = Type.GetType(typeName);
		if (type == null)
		{
			Console.Error.WriteLine($"Could not get type '{typeName}'");
			continue;
		}

		foreach (XmlElement usingNode in typeNode.SelectNodes(@"using"))
		{
			var usingNamespace = usingNode.Attributes["namespace"]?.Value;
			if (usingNamespace != null)
			{
#>
using <#= usingNamespace #>;
<#
			}
		}
#>

namespace Extellect.SystemTypes
{
	public interface I<#= type.Name #>
	{
		#region Properties
<#
		foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
		{
			if (property.CanRead)
			{
				if (property.CanWrite)
				{
#>
		<#= DisplayName(property.PropertyType) #> <#= property.Name #> { get; set; }
<#
				}
				else
				{
#>
		<#= DisplayName(property.PropertyType) #> <#= property.Name #> { get; }
<#
				}
			}
			else if (property.CanWrite)
			{
#>
		<#= DisplayName(property.PropertyType) #> <#= property.Name #> { set; }
<#
			}
		}
#>
		#endregion

		#region Methods
<#
		foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
		{
			if (method.IsSpecialName)
			{
				continue;
			}
#>
		<#= DisplayName(method.ReturnType) #> <#= method.Name #>(<#= DisplayParameters(method.GetParameters()) #>);
<#
		}
#>
		#endregion
	}
}
<#
	}
#>

#endif
<#+

private static IEnumerable<Type> DeclaringTypeGenericArguments(Type type)
{
    if (type.DeclaringType != null && type.DeclaringType.IsGenericType)
    {
        return type.DeclaringType.GetGenericArguments();
    }
    return Enumerable.Empty<Type>();
}

private static string DisplayName(Type type)
{
    var typeNameBuilder = new StringBuilder();
    if (type.DeclaringType != null)
    {
        typeNameBuilder.Append(DisplayName(type.DeclaringType));
        typeNameBuilder.Append(".");
    }

    if (type.IsGenericType)
    {
        var genericArgumentCount = 0;
        foreach (var genericArgument in type.GetGenericArguments().Except(DeclaringTypeGenericArguments(type), new DelegateEqualityComparer<Type>((x, y) => x.Name.Equals(y.Name), obj => obj.Name.GetHashCode())))
        {
            genericArgumentCount++;
            if (typeNameBuilder.Length > 0)
            {
                typeNameBuilder.Append(", ");
            }
            typeNameBuilder.Append(genericArgument.Name);
        }

        if (genericArgumentCount > 0)
        {
            typeNameBuilder.Append(">");
            typeNameBuilder.Insert(0, "<");
            typeNameBuilder.Insert(0, type.Name.Substring(0, type.Name.IndexOf('`')));
        }
        else
        {
            // nested class without generic arguments of its own
            typeNameBuilder.Append(type.Name);
        }
    }
    else
    {
        typeNameBuilder.Append(type.Name);
    }
    return typeNameBuilder.ToString();
}

private string DisplayParameters(IEnumerable<ParameterInfo> parameters)
{
	return string.Join(", ", parameters.Select(x => $"{DisplayName(x.ParameterType)} {x.Name}"));
}
#>
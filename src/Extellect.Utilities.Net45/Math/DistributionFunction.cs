#pragma warning disable 1591
using Extellect.Utilities.Sequencing;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Extellect.Utilities.Math
{
    /// <summary>
    /// Factory (and a couple of implementations) for distributions that are mapped to
    /// the uniform distribution as exposed by System.Random.
    /// 
    /// To add more distributions:
    /// 1: determine the x-axis range over which the function will be used
    /// 2: scale the upper limit of the uniform distribution (i.e. 1) to that new limit (do this using the definite integral)
    /// 3: apply the inverse definite integral to the random number generated by the uniform distribution
    /// 4: decide whether or not to scale the result
    /// </summary>
    public abstract class DistributionFunction : IDistributionFunction
    {
        private readonly IIterable<double> _randoms;
        private readonly Range<double> _interval;
        
        public DistributionFunction(IIterable<double> randoms, double low, double high)
        {
            _randoms = randoms;
            _interval = new Range<double>(low, high);
        }

        public double NextDouble() => InverseIntegral(Integral(Interval.MinValue) + Scale(_randoms.Next()));

        public Range<double> Interval => _interval;

        protected abstract double Integral(double x);

        protected abstract double InverseIntegral(double x);

        /// <summary>
        /// Scales a random number between 0 and 1 up to the area under the target distribution (its definite integral)
        /// </summary>
        private double Scale(double x) => x * DefiniteIntegral;

        private double DefiniteIntegral => Integral(Interval.MaxValue) - Integral(Interval.MinValue);

        public double Adjust(double x) => (x - Interval.MinValue) / (Interval.MaxValue - Interval.MinValue);

        private class SinDistributionFunction : DistributionFunction
        {
            public SinDistributionFunction(IIterable<double> randoms, double low, double high)
                : base(randoms, low, high)
            {
            }

            protected override double Integral(double x) => 0 - System.Math.Cos(x);

            protected override double InverseIntegral(double x) => System.Math.Acos(0 - x);
        }

        private class CosDistributionFunction : DistributionFunction
        {
            public CosDistributionFunction(IIterable<double> randoms, double low, double high)
                : base(randoms, low, high)
            {
                if (high - low > System.Math.PI * 2)
                {
                    throw new ArgumentException("Interval cannot be greater than 2π");
                }
            }

            protected override double Integral(double x) => System.Math.Sin(x);

            protected override double InverseIntegral(double x) => System.Math.Asin(x);
        }

        private class LinearDistributionFunction : DistributionFunction
        {
            private double _slope;
            private double _intercept;

            public LinearDistributionFunction(IIterable<double> randoms, double low, double high, double slope, double intercept)
                : base(randoms, low, high)
            {
                _slope = slope;
                _intercept = intercept;
            }

            protected override double Integral(double x) => _intercept * x + (_slope / 2) * x * x;

            protected override double InverseIntegral(double x) => (-x - System.Math.Sqrt(4 * _slope * _intercept + x * x)) / (2 * _slope);
        }

        public static DistributionFunction Linear(IIterable<double> randoms) => new LinearDistributionFunction(randoms, 0, System.Math.Sqrt(2), -1, System.Math.Sqrt(2));

        public static DistributionFunction Sin(IIterable<double> randoms, double low = 0, double high = System.Math.PI) => new SinDistributionFunction(randoms, low, high);

        public static DistributionFunction Cos(IIterable<double> randoms, double low = 0, double high = System.Math.PI / 2d) => new CosDistributionFunction(randoms, low, high);
    }
}
